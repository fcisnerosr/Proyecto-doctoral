function [comac_error] = RMSEfunction(x, num_element_sub, M_cond, frec_cond_d,...
    L, ID, NE, elements, nodes, IDmax, NEn, damele, eledent, A, Iy, Iz, J, E, G, ...
    vxz, elem_con_dano_long_NE,...
    modos_cond_d, prop_geom_mat, comac_values, comac_ref, nodos, modos)
    % Inicializa la variable objetivo
    % Objetivo  = 0;
    % Pesos para las funciones objetivo
    % w1 = 0.6;  % Peso al RMSE
    % w2 = 0.4;  % Peso al MACN

    % w1 = 1;  % Peso al RMSE
    % w2 = 0;  % Peso al MACN

    % w1 = 5000;  % Peso al RMSE
    % w2 = 5000;  % Peso al COMAC
    
    % Recorta las propiedades a la subestructura
    L_sub  = L(1:num_element_sub);   
    A_sub  = A(1:num_element_sub);   
    Iy_sub = Iy(1:num_element_sub);  
    Iz_sub = Iz(1:num_element_sub);
    E_sub  = E(1:num_element_sub);
    G_sub  = G(1:num_element_sub);
    J_sub  = J(1:num_element_sub);
    
    ke_AG_tensor = zeros(12,12,num_element_sub);
    % Recorre cada uno de los num_element_sub elementos para aplicar el daño
   
    for i = 1:num_element_sub
    % for i = 1:1
        % Matriz de rigidez local
        ke_AG = zeros(12,12);

        % % Aplica daño al espesor
        t = prop_geom_mat(i,10);
        t_corro = x(i) * t; % Espesor que va a restar al espesor sin dano
        t_d = t - t_corro; % Espesor ya reducido
        % Área con corrosión
        D = prop_geom_mat(i,9);
        D_d = D - (2*t_corro);
        R_d = 0.5 * D_d;
        A1_d = pi * R_d^2;
        R_interior_d = 0.5 * (D_d - (2*t_d));
        A2_d = pi  * R_interior_d^2;
        A_damaged = A1_d - A2_d; % en mm^2
        % Momento de inercia con daño
        I_ext_d = 1/4 * pi * R_d^4;
        I_int_d = 1/4 * pi * R_interior_d^4;
        Iy_damaged = I_ext_d - I_int_d;
        Iz_damaged = Iy_damaged;        

        % Modifica los términos afectados en la matriz de rigidez local
        % Elementos de la diagonal principal
        ke_AG(1, 1)  =  E_sub(i)        * A_damaged  / L_sub(i);
        ke_AG(2, 2)  =  12 * E_sub(i)   * Iz_damaged / L_sub(i)^3;
        ke_AG(3, 3)  =  12 * E_sub(i)   * Iy_damaged / L_sub(i)^3;
        ke_AG(4, 4)  =  (G_sub(i)       * J_sub(i))  / L_sub(i);
        ke_AG(5, 5)  =  4 * E_sub(i)    * Iy_damaged / L_sub(i);
        ke_AG(6, 6)  =  4 * E_sub(i)    * Iz_damaged / L_sub(i);
        ke_AG(7, 7)  =  E_sub(i)        * A_damaged  / L_sub(i);
        ke_AG(8, 8)  =  12 * E_sub(i)   * Iy_damaged / L_sub(i)^3;
        ke_AG(9, 9)  =  12 * E_sub(i)   * Iz_damaged / L_sub(i)^3;
        ke_AG(10, 10) = (G_sub(i)       * J_sub(i))  / L_sub(i);
        ke_AG(11, 11) = 4 * E_sub(i)    * Iy_damaged / L_sub(i);
        ke_AG(12, 12) = 4 * E_sub(i)    * Iz_damaged / L_sub(i);
        
        % Resto de los elementos de la matriz de rigidez local
        ke_AG(7, 1) = -ke_AG(1, 1);
        ke_AG(6, 2) = (6                * E_sub(i) * Iz_damaged) / L_sub(i)^2;
        ke_AG(8, 2) = (-12              * E_sub(i) * Iz_damaged) / L_sub(i)^3;
        ke_AG(12,2) = (6                * E_sub(i) * Iz_damaged) / L_sub(i)^2;
        ke_AG(5, 3) = -(6               * E_sub(i) * Iy_damaged) / L_sub(i)^2;
        ke_AG(9, 3) = (-12              * E_sub(i) * Iy_damaged) / L_sub(i)^3;
        ke_AG(11,3) = (-6               * E_sub(i) * Iy_damaged) / L_sub(i)^2;
        ke_AG(10,4) = (-G_sub(i)        * J_sub(i))   / L_sub(i);
        ke_AG(9, 5) = (6    * E_sub(i)  * Iy_damaged) / L_sub(i)^2;
        ke_AG(11,5) = 2     * E_sub(i)  * Iy_damaged  / L_sub(i);
        ke_AG(8, 6) = (-6   * E_sub(i)  * Iz_damaged) / L_sub(i)^2;
        ke_AG(12,6) = (2    * E_sub(i)  * Iz_damaged) / L_sub(i);
        ke_AG(12,8) = (-6   * E_sub(i)  * Iz_damaged) / L_sub(i)^2;
        ke_AG(11,9) = (6    * E_sub(i)  * Iy_damaged) / L_sub(i)^2;
        
        % Las siguientes lineas acompleta el resto de la matriz de rigidez a fin de que quede simetrica
        
        keT = ke_AG';
        kediag = diag(diag(ke_AG));
        ke_AG = ke_AG + keT - kediag;
       
        ke_AG_tensor(:,:,i) = ke_AG;
        
   end

    % Reensamblar la matriz global de rigidez con daño del AG
    [KG_AG] = ensamblaje_matriz_rigidez_global_AG(num_element_sub,ke_AG_tensor,ID, NE, elements, nodes, IDmax, NEn, damele, eledent, A, Iy, Iz, J, E, G, vxz, elem_con_dano_long_NE);
    
    % Condensación estática de matrices globales
    KG_AG_cond              = condensacion_estatica_AG(KG_AG);
    [modos_AG_cond,frec_AG] = modos_frecuencias_AG(KG_AG_cond,M_cond);

    % %%% Verificación de numeros reales en mis frecuencias y formas
    % % Verificar si las matrices contienen solo números reales
    % real_modos_cond_d = isreal(modos_AG_cond);
    % real_frec_cond_d  = isreal(frec_AG);
    % if real_frec_cond_d == 0
    %     print('Frecuencias con numeros imaginarios\n')
    % end
    % 
    % SumRMSEVal = 0;
    % for i = 1:length(frec_AG)
    %     % SumRMSEVal = SumRMSEVal + (frec_AG(i) - frec_cond_d(i))^2;
    %     SumRMSEVal = SumRMSEVal + ((2*pi/frec_AG(i)) - (2*pi/frec_cond_d(i)))^2;
    % end
    % RMSE = sqrt(SumRMSEVal / length(frec_AG));  

    
    % % Calcular el MACN para formas modales
    % macn_value = 0;
    % for i = 1:size(modos_cond_d, 2)
    %     num = (modos_cond_d(:,i)' * modos_AG_cond(:,i))^2;
    %     den = (modos_cond_d(:,i)' * modos_cond_d(:,i)) * (modos_AG_cond(:,i)' * modos_AG_cond(:,i));
    %     MAC_value = num / den;
    %     macn_value = macn_value + sqrt((1 - MAC_value) / MAC_value);
    % end
    % macn_value = macn_value / size(modos_cond_d, 2);  % Promedio de MACN

    % [num_nodos, num_modos] = size(modos_cond_d);
    % 
    % % Inicializar matriz COMAC
    % comac = zeros(num_nodos, num_modos);
    % 
    % % Calcular el COMAC para cada nodo y cada modo
    % for j = 1:num_modos
    %     for i = 1:num_nodos
    %         numerador = sum(modos_cond_d(i,j) * modos_AG_cond(i,j));
    %         denominador = sqrt(sum(modos_cond_d(i,j)^2) * sum(modos_AG_cond(i,j)^2));
    %         comac(i,j) = (numerador / denominador)^2
    %     end
    % end
    % Calcular el CoMAC para cada nodo en cada modo
    % comac_values = zeros(size(modos_AG_cond, 1), size(modos_cond_d, 2));
    % for i = 1:size(modos_cond_d, 2)
    %     for node = 1:size(modos_AG_cond, 1)
    %         num = (modos_cond_d(node, i) * modos_AG_cond(node, i))^2;
    %         den = (modos_cond_d(node, i)^2) * (modos_AG_cond(node, i)^2);
    %         comac_values(node, i) = num / den;
    %     end
    % end
    
    
    % % Calcular una métrica escalar a partir del vector CoMAC
    % comac_metric = (sum(sum((1 - comac_values).^2))) * 50000000000

    % % Usar la métrica CoMAC en la función objetivo
    % Objetivo = (w1 * RMSE) + (w2 * comac_metric);

    % Normalización de las formas modales por el máximo valor absoluto
    for i = 1:size(modos_cond_d, 2)
        modos_cond_d(:, i) = modos_cond_d(:, i) / max(abs(modos_cond_d(:, i)));
        modos_AG_cond(:, i) = modos_AG_cond(:, i) / max(abs(modos_AG_cond(:, i)));
    end
    modos_cond_d = modos_cond_d*5000;
    modos_AG_cond = modos_AG_cond*5000;

    % Cálculo de COMAC nodo a nodo
    for i = 1:3  % Iterar sobre cada modo
        for node = 1:216  % Iterar sobre cada nodo
            num = (modos_cond_d(node, i) * modos_AG_cond(node, i))^2;
            den = (modos_cond_d(node, i)^2) * (modos_AG_cond(node, i)^2);
            comac_values(node, i) = num / den;  % Fórmula de COMAC
        end
    end
    % Calcular el error cuadrático medio de las desviaciones del COMAC de la unidad
    comac_error = mean((1 - comac_values(:)).^2)
end


