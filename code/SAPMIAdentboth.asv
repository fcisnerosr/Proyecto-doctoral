%% SAPMIAdenthboth.m

% Main
clc; clear all; close all, warning off
tic
format shortG

% Datos iniciales de entrada
% Marco inclinado
% archivo_excel = 'E:\Archivos_Jaret\Proyecto-doctoral\pruebas_excel\marco_elementos_inclinados.xlsx';

% Elemento a elemento
archivo_excel = 'E:\Archivos_Jaret\Proyecto-doctoral_error\pruebas_excel\ETABS_modelo\ETABS\revision_2_marco_elemento_a_elemento\datos_prueba2.xlsx';

%Jacket
% archivo_excel = 'E:\Archivos_Jaret\Proyecto-doctoral\pruebas_excel\Datos_nudos_elementos_secciones_masas_nuevo_pend1a8_vigasI.xlsx';

tirante         = 87000;    % en mm
tiempo          = 03;       % en anos
d_agua          = 1.07487 * 10^-8; % unidades de la densidad del agua en N/mm^3
% d_agua          = 0; % unidades de la densidad del agua en N/mm^3
densidad_crec   = 1.3506*10^-7;    % en N/mm^3
% densidad_crec   = 0;    % en N/mm^3
% Valor de la dessidad del crecimiento marino
% Valor de encontrado en internet = 1325 kg/m^3
% Conversión: 1325 kg/m^3 * (1 N / 9.81 kg) * (1 m^3/1000^3 m^3) = 1.3506*10^-7 en N/mm^3
pathfile        = 'E:\Archivos_Jaret\Proyecto-doctoral_error\pruebas_excel\marco3Ddam0.xlsx';
% pathfile = '/home/francisco/Documents/Proyecto-doctoral/pruebas_excel/marco3Ddam0.xlsx';

% Danos a elementos tubulares, caso de dano y su respectivo porcentaje
no_elemento_a_danar = 1;
caso_dano           = repmat({'corrosion'}, 1, length(no_elemento_a_danar));
dano_porcentaje     = [0.000];  % El dano va en decimal y se debe incluir el numero de elementos con dano dentro de un vector

% Corregir de formato los números en la tabla importada de ETABS: En todo este bloque de código, se realizó el cambio de formato de los números, debido a que ETABS importa sus tablas en formato de texto en algunas columnas.
% % % % correccion_format_TablaETABS(archivo_excel);

% CONDICIONES IMPRESINDIBLES: ESTE CÓDIGO ESTÁ REALIZADO PARA EXTRAER LOS DATOS DEL MODELO EN ETABS
% 1.- LOS ELEMENTOS DEBEN CONSTRUIRSE Y CONECTARSE DEL LECHO MARINO HASTA LA SUPER ESTRUCTURA
% 2.- LOS ELEMENTOS DEBEN TENER UN "Unique name" SECUENCIAL DE MENOR A MAYOR CONSTRUIDO DESDE ABAJO HASTA ARRIBA (NO IMPORTA EL ORDEN EN CADA STORY)
%     EL Unique name ES UNA ETIQUETA QUE ETABS LE DA A CADA ELEMENTO Y SI SE USA EL "SPLIT" PARA DIVIDIR ELEMENTOS
%     ES IMPORTANTE REESCRIBIRLOS A MANO PARA QUE VAYAN SECUENCIALMENTE SIN SALTARSE NINGÚN NÚMERO
%     DESDE 1 HASTA LOS n ELEMENTOS QUE VAYA A TENER LA PLATAFORMA

% Lectura de datos del modelo de ETABS
[coordenadas, conectividad, propgeom, matriz_restriccion, matriz_cell_secciones, VXZ] = lectura_datos_modelo_ETABS(archivo_excel);
    %% SECCIÓN: pestaña "nudos"
    %% BLOQUE: Nodos y sus coordenadas (coordenadas)
    hoja_excel = 'Point Object Connectivity';
    coordenadas_crudo = readmatrix(archivo_excel, 'Sheet', hoja_excel);
    % coordenadas_crudo = readmatrix(archivo_excel, 'Sheet', hoja_excel, 'Range', '');
    coordenadas = sortrows(coordenadas_crudo, 1);   % Extraccion de matriz de tabla de pestana de excel
    % proceso de limpieza de datos para armar correctamente la matriz para la hoja del dr Rolando
    primer_col = coordenadas(:,1);
    primer_col = primer_col(~isnan(primer_col));
    coordenadas_num = coordenadas(:, 6:8);
    coordenadas_num = coordenadas_num(~any(isnan(coordenadas_num), 2), :);
    coordenadas = horzcat(primer_col, coordenadas_num);

    %% SECCIÓN: pestaña "conectividad"
    %% BLOQUE: extracción de qué nudos está cada viga y columna del modelo (conectividad)
    % Extracción de datos de las vigas
    hoja_excel = 'Beam Object Connectivity';
    vigas = readmatrix(archivo_excel, 'Sheet', hoja_excel);
    cols_con_nan = any(isnan(vigas), 1);
    vigas(:, cols_con_nan) = [];
    vigas(:,4) = [];
    vigas_conectividad = vigas;
    % Extracción de datos de las columas diagonales (tanto en la subestructura como en al superestructura)
    hoja_excel = 'Brace Object Connectivity'; % pestaña con elementos diagonales (generalmente ubicados en la subestructura)
    col_diag = readmatrix(archivo_excel, 'Sheet', hoja_excel);
    cols_con_nan = any(isnan(col_diag), 1);
    col_diag(:, cols_con_nan) = [];
    col_diag(:,4) = [];
    col_diag_conectividad = col_diag;
    % Extracción de datos de las columas rectas (tanto en la subestructura como en al superestructura)
    hoja_excel = 'Column Object Connectivity'; % pestaña con columnas rectas (generalmente ubicados en la superestructura)
    col = readmatrix(archivo_excel, 'Sheet', hoja_excel);
    cols_con_nan = any(isnan(col), 1);
    col(:, cols_con_nan) = [];
    col(:,4) = [];
    col_conectividad = col;
    % Concatenación de las vigas y columnas
    conectividad = vertcat(vigas_conectividad, col_diag_conectividad,col_conectividad);   % Matriz con todos los elementos y entre qué y qué nodos está conectados
    conectividad = sortrows(conectividad, 1);                           % Matriz organizada con todos los elementos y entre qué nudos está cada elemento frame
    conectividad = conectividad(:,1:3);

    %% SECCIÓN: pestaña "prop geom"
    %% BLOQUE: Estracción de módulos de elasticidad y cortante (E y G)
    % Datos en este proceso: extracción de las propiedades de los elementos y asignación
    % Propiedades del material (módulos)
    hoja_excel = 'Mat Prop - Basic Mech Props';
    % Lee los datos de la columna A desde la celda A4 hasta el final de la columna
    E = xlsread(archivo_excel, hoja_excel, 'E7');      % módulo de elasticidad en MPa del modelo en ETABS
    G = xlsread(archivo_excel, hoja_excel, 'F7');        % módulo de corte en MPa del modelo en ETABS
    % Secciones transversales a cada elemento en el modelo
    hoja_excel = 'Frame Prop - Summary';
    % Lee los datos de la columna A desde la celda A4 hasta el final de la columna
    [numeros, secciones] = xlsread(archivo_excel, hoja_excel, 'A4:A100');   % Contiene elementos tipo SECC01, SECC02, hasta extraer todos las secciones del modelo
    % %% Propiedades del material del modelo en ETABS
    % Extracción y organización de las propiedades de ETABS para EXCEL
    tabla_frame_prop_summary = readtable(archivo_excel, 'Sheet', hoja_excel);
    tabla_frame_prop_summary(1,:) = [];
    vector_organizado_con_propiedades = table2cell(tabla_frame_prop_summary(:,5:8));
    %% Proceso de organización de las columnas para que correspondan al EXCEL del dr. Rolando
    vector_organizado_con_propiedades = horzcat(...
            vector_organizado_con_propiedades(:,1),...  % Área transversal
            vector_organizado_con_propiedades(:,3),...  % I_yy, I_33 en ETABS
            vector_organizado_con_propiedades(:,4),...  % I_zz, I_22 en ETABS
            vector_organizado_con_propiedades(:,2));    % Módulo J
    % A la variable "vector_organizado_con_propiedades" le faltan las dos columnas del módulo de elasticidad y el módulo G.
    % Estas dos últimas columnas deben concatenadas al final de "vector_organizado_con_propiedades"
    % ya que así lo requiere el XLSX del dr. Rolando.
    %% Proceso de concatenación de los vectores columnas de E y G
    num_filas = size(vector_organizado_con_propiedades, 1);
    E = E * ones(num_filas, 1);
    G = G * ones(num_filas, 1);

    %% BLOQUE: Estracción de módulos de elasticidad y cortante (E y G)
    % Concatenación de la matriz "vector_organizado_con_propiedades" y los dos vectores columna E y G
    vector_organizado_con_propiedades = [cell2mat(vector_organizado_con_propiedades), E, G];
    vector_organizado_con_propiedades = num2cell(vector_organizado_con_propiedades);
    % Concateniacón de la lista de SECC01, SECC02, ..., SECCn en la subestructura
    % y SteelBm y SteelCol de la superestructura
    % secciones existentes en el modelo, con las propiedades mecánicas
    cell_seccion = horzcat(secciones,vector_organizado_con_propiedades); % cell con la sección la SECC01, SECC02, ..., SECCn y SteelBm y SteelCol
    % y sus repectivas propiedades mecánicas

    %% BLOQUE: Cell con todos los UniqueNames y los nombres de la secciones transversales (matriz_cell_secciones)
    % Asignación de cada elemento a su respectiva sección
    % Proceso concatenar la lista de SECC01, SECC02, ..., SECCn, SteelBm y SteelCol (Todos los elementos)
    % con el UniqueName del modelo en ETABS
    hoja_excel = 'Frame Assigns - Sect Prop';
    tabla_Frame_Assigns_Sect_Prop = readtable(archivo_excel, 'Sheet', hoja_excel);
    secciones_cada_elemento = tabla_Frame_Assigns_Sect_Prop.SectionProperty;
    unique_name = num2cell(tabla_Frame_Assigns_Sect_Prop.UniqueName);               % Vector columna con todos los "unique name" de cada elemento frame
    matriz_cell_secciones = horzcat(unique_name, secciones_cada_elemento);
    matriz_cell_secciones(:,1) = [];
    matriz_cell_secciones = sortrows(matriz_cell_secciones, 1);                     % Los elementos se extraen desorganizadamente, por lo que se ordena en esta línea
    % 
    %% BLOQUE: Áreas, inercia, mom. polar, elasticidades y corte (propiedades)
    % Bucle for para la asignación
    % "secciones" es una variable con los tipos de secciones en el modelo. Es un cell array pequeño de no más de 20 elementos
    prop_geom = cell(size(matriz_cell_secciones));  % valores_asignados es un cell que usa para asignar todos las propiedades
    % de las secciones del modelo organizadas acorde a la lista de elementos de toda la plataforma
    % Proceso de iteración sobre cada fila de matriz_cell_secciones
    for i = 1:size(matriz_cell_secciones, 1)
        % Obtener el valor de la primera columna de la fila actual
        % seccion_actual = matriz_cell_secciones{i, 2};   & ajustes por cambio de Jacket a marco
        seccion_actual = matriz_cell_secciones{i, 1};
        % Buscar la fila correspondiente en cell_seccion
        idx = find(strcmp(seccion_actual, cell_seccion(:, 1)));
        % Asignar los valores de cell_seccion a la matriz de salida
        if ~isempty(idx)
            prop_geom{i, 1} = cell_seccion{idx, 2};
            prop_geom{i, 2} = cell_seccion{idx, 3};
            prop_geom{i, 3} = cell_seccion{idx, 4};
            prop_geom{i, 4} = cell_seccion{idx, 5};
            % prop_geom{i, 5} = cell_seccion{idx, 6};   & ajustes por cambio de Jacket a marco
            % prop_geom{i, 6} = cell_seccion{idx, 7};   & ajustes por cambio de Jacket a marco
        end
    end
    propiedades = prop_geom;

    %% BLOQUE: Columnas adicionales de tabla (wo_vector, gamma_beta_vector, tipo)
    % Creación de vector 'wo'
    wo_vector = cell(length(prop_geom),1);
    for i = 1:length(prop_geom)
        wo_vector{i} = ['wo'];
    end
    % Creación de vector 'gamma y beta'
    gamma_beta_vector = zeros(length(prop_geom),2);
    for i = 1:length(gamma_beta_vector)
        gamma_beta_vector(i,1) = 7.809E-09;
        gamma_beta_vector(i,2) = 0.65;
    end
    gamma_beta_vector = num2cell(gamma_beta_vector);
    % Adicionar 3 columnas más: de tipo de elementos, radio y espesor en mm
    % tipo de elemento
    tipo = cell(length(prop_geom), 1);
    for i = 1:length(tipo)
        tipo{i} = ['circular'];
    end

    %% BLOQUE: Diámetros y espesores de todos las secciones transversales de la plataforma
    % SUBLOQUE: Diámetros y espesores de los elementos tubulares de la subestructura (vector_thickness y vecto_diametros)
    % diam y espesor de elemento
    % tabla de donde extraen los diametros y espesores de cada tipo de sección en el modelo
    hoja_excel = 'Frame Sec Def - Steel Pipe';
    tabla_diam_thick = readtable(archivo_excel, 'Sheet', hoja_excel);
    tabla_diam_thick(1,:) = [];
    tabla_diam_thick(:,2:3) = [];
    tabla_diam_thick(:,4:end) = [];
    % tabla con todas las secciones, su UniqueName y SECC correspondiente
    hoja_excel = 'Frame Assigns - Summary';
    tabla_frame_assigns_summary = readtable(archivo_excel, 'Sheet', hoja_excel);
    tabla_a_filtrar = readtable(archivo_excel, 'Sheet', hoja_excel);
    indices = ~contains(tabla_a_filtrar.Story, 'Super');
    tabla_filtrada = tabla_a_filtrar(indices, :);
    tabla_frame_assigns_summary = tabla_filtrada;
    tabla_frame_assigns_summary(1,:) = [];
    tabla_frame_assigns_summary(:,1:2) = [];
    tabla_frame_assigns_summary(:,2:4) = [];
    tabla_frame_assigns_summary(:,3:4) = [];
    tabla_frame_assigns_summary = sortrows(tabla_frame_assigns_summary);
    % luego se realiza una asignación y de cada elemento y sección con su diámetro y su espesor
    vector_diametros = zeros(height(tabla_frame_assigns_summary), 1);
    vector_thickness = zeros(height(tabla_frame_assigns_summary), 1);
    % Recorrer cada fila de tabla_frame_assigns_summary
    for i = 1:height(tabla_frame_assigns_summary)
        % Obtener el DesignSection de la fila actual
        design_section = tabla_frame_assigns_summary.DesignSection{i};
        % Encontrar la fila correspondiente en tabla_diam_thick
        indice = find(strcmp(tabla_diam_thick.Name, design_section));
        % Extraer OutsideDiameter y WallThickness
        if ~isempty(indice)
            vector_diametros(i) = tabla_diam_thick.OutsideDiameter(indice);
            vector_thickness(i) = tabla_diam_thick.WallThickness(indice);
        else
            % Si el DesignSection no se encuentra, puedes asignar un valor por defecto o manejarlo según sea necesario
            vector_diametros(i) = NaN;
            vector_thickness(i) = NaN;
        end
    end
    vector_diametros_sub = vector_diametros;
    vector_thickness_sub = vector_thickness;
    vector_diametros_sub = num2cell(vector_diametros_sub);
    vector_thickness_sub = num2cell(vector_thickness_sub);
    UniqueName = tabla_frame_assigns_summary(:,1);
    diam_diam_thick_tube_sub = horzcat(UniqueName, vector_diametros_sub, vector_diametros_sub, vector_thickness_sub);

    % Esta seccion se omite porque en el marco de estudio no existe superestructura 
    % % SUBLOQUE: Diametros y espesores de los elementos elementos tubulares de la superestructura (vector_diametros_tube_super y vector_thickness__tube_super)
    % hoja_excel = 'Frame Assigns - Summary';
    % tabla_frame_assigns_summary = readtable(archivo_excel, 'Sheet', hoja_excel);
    % tabla_frame_assigns_summary(1,:) = [];
    % tabla_a_filtrar = readtable(archivo_excel, 'Sheet', hoja_excel);
    % tabla_a_filtrar(1,:) = [];
    % indices = ~contains(tabla_a_filtrar.Story, 'Story');
    % tabla_filtrada = tabla_a_filtrar(indices, :)
    % indices = ~contains(tabla_filtrada.DesignType, 'Beam');
    % tabla_filtrada = tabla_filtrada(indices, :);
    % tabla_frame_assigns_summary_tube_super = tabla_filtrada;
    % tabla_frame_assigns_summary_tube_super(:,1:2) = [];
    % tabla_frame_assigns_summary_tube_super(:,2:4) = [];
    % tabla_frame_assigns_summary_tube_super(:,3:end) = [];
    % % luego se realiza una asignación y de cada elemento y sección con su diámetro y su espesor
    % vector_diametros_tube_super = zeros(height(tabla_frame_assigns_summary_tube_super), 1);
    % vector_thickness_tube_super = zeros(height(tabla_frame_assigns_summary_tube_super), 1);
    % % Recorrer cada fila de tabla_frame_assigns_summary
    % for i = 1:height(tabla_frame_assigns_summary_tube_super)
    %     % Obtener el DesignSection de la fila actual
    %     design_section = tabla_frame_assigns_summary_tube_super.DesignSection{i};
    %     % Encontrar la fila correspondiente en tabla_diam_thick
    %     indice = find(strcmp(tabla_diam_thick.Name, design_section));
    %     % Extraer OutsideDiameter y WallThickness
    %     if ~isempty(indice)
    %         vector_diametros_tube_super(i) = tabla_diam_thick.OutsideDiameter(indice);
    %         vector_thickness_tube_super(i) = tabla_diam_thick.WallThickness(indice);
    %     else
    %         % Si el DesignSection no se encuentra, puedes asignar un valor por defecto o manejarlo según sea necesario
    %         vector_diametros_tube_super(i) = NaN;
    %         vector_thickness_tube_super(i) = NaN;
    %     end
    % end
    % vector_diametros_tube_super = num2cell(vector_diametros_tube_super);
    % vector_thickness_tube_super = num2cell(vector_thickness_tube_super);
    % UniqueName = tabla_frame_assigns_summary_tube_super(:,1);
    % diam_diam_thick_tube_super = horzcat(UniqueName, vector_diametros_tube_super, vector_diametros_tube_super, vector_thickness_tube_super)

    % %%% Parte comentada - inicio: en el marco no hay vigas en I
    % % % SUBLOQUE: Diámetros y espesores de los elementos IR de la superestructura (vector_diametros_I y vector_thickness_I)
    % % hoja_excel = 'Frame Sec Def - Steel I';
    % % tabla_diam_thick_I = readtable(archivo_excel, 'Sheet', hoja_excel);
    % % tabla_diam_thick_I(1,:) = [];
    % % tabla_diam_thick_I(:,1:4) = [];
    % % tabla_diam_thick_I(:,3) = [];
    % % tabla_diam_thick_I(:,3) = [];
    % % tabla_diam_thick_I(:,4:end) = [];
    % % hoja_excel = 'Frame Assigns - Summary';    
    % % tabla_frame_assigns_summary_I = readtable(archivo_excel, 'Sheet', hoja_excel);
    % % tabla_frame_assigns_summary_I(1,:) = [];
    % % tabla_a_filtrar = readtable(archivo_excel, 'Sheet', hoja_excel);
    % % indices = ~contains(tabla_a_filtrar.Story, 'Story');
    % % tabla_filtrada = tabla_a_filtrar(indices, :);
    % % tabla_filtrada(1,:) = [];
    % % tabla_filtrada = sortrows(tabla_filtrada, {'DesignType', 'UniqueName'});
    % % indices = ~contains(tabla_filtrada.Label, 'C');
    % % tabla_filtrada = tabla_filtrada(indices, :);
    % % tabla_frame_assigns_summary_I = tabla_filtrada;
    % % tabla_frame_assigns_summary_I(:,1:2) = [];
    % % tabla_frame_assigns_summary_I(:,2:4) = [];
    % % tabla_frame_assigns_summary_I(:,3:end) = [];
    % % tabla_frame_assigns_summary_I = sortrows(tabla_frame_assigns_summary_I);
    % % vector_diametros_I = zeros(height(tabla_frame_assigns_summary_I), 1);
    % % vector_thickness_I = zeros(height(tabla_frame_assigns_summary_I), 1);
    % % % Recorrer cada fila de tabla_frame_assigns_summary_I
    % % for i = 1:height(tabla_frame_assigns_summary_I)
    % %     % Obtener el DesignSection de la fila actual
    % %     design_section = tabla_frame_assigns_summary_I.DesignSection{i};
    % %     % Encontrar la fila correspondiente en tabla_diam_thick
    % %     indice = find(strcmp(tabla_diam_thick_I.SectionInFile, design_section));
    % %     % Extraer OutsideDiameter y WallThickness
    % %     if ~isempty(indice)
    % %         vector_diametros_I(i) = tabla_diam_thick_I.TotalDepth(indice);
    % %         vector_thickness_I(i) = tabla_diam_thick_I.WebThickness(indice);
    % %     else
    % %         % Si el DesignSection no se encuentra, puedes asignar un valor por defecto o manejarlo según sea necesario
    % %         vector_diametros_I(i) = NaN;
    % %         vector_thickness_I(i) = NaN;
    % %     end
    % % end
    % % vector_diametros_I = num2cell(vector_diametros_I);
    % % vector_thickness_I = num2cell(vector_thickness_I);
    % % UniqueName = tabla_frame_assigns_summary_I(:,1);
    % % diam_diam_thick_I = horzcat(UniqueName, vector_diametros_I, vector_diametros_I, vector_thickness_I);
    % % diam_diam_th = vertcat(diam_diam_thick_tube_sub, diam_diam_thick_tube_super, diam_diam_thick_I);
    % % diam_diam_th = sortrows(diam_diam_th);
    % % diam_diam_th = table2cell(diam_diam_th);
    % % diam_diam_th(:,1) = [];
    % %%% Parte comentada - fin: en el marco no hay vigas en I
    % 
    % SUBLOQUE: Pasos finales (prop_geom)
    % Concatenación final y conversión final de los cell arrays en matrices
        % Se realizan algunos ajustes finales para ahora que se cambio la estructura a un marco sencillo
    hoja_excel = 'Frame Assigns - Frame Auto Mesh';
    % Leer la columna "C" desde la fila 4 en adelante
    rango = 'C4:C20'; % Se asume un límite alto (ajusta si es necesario)
    % Extraer los datos numéricos de la columna sin importar el número de filas
    numero_frame = readmatrix(archivo_excel, 'Sheet', hoja_excel, 'Range', rango);
    numero_frame = numero_frame(~isnan(numero_frame));
    E_columna = E * ones(length(numero_frame), 1);
    G_columna = G * ones(length(numero_frame), 1);
    elementos = num2cell(numero_frame);
    elementos = string(elementos);
    prop_geom = cellfun(@num2str, prop_geom, 'UniformOutput', false);
    prop_geom = string(prop_geom);
    prop_geom = [elementos, prop_geom];
    prop_geom = sortrows(prop_geom);            % Matriz organizada con cada elemento y sus propiedades extraídas del ETABS
    % Conversion de tablas a celdas para poder concatenar
    diam_diam_thick_tube_sub(:,1) = [];
    diam_diam_thick_tube_sub_cell = table2cell(diam_diam_thick_tube_sub);
    % Convertir la matriz de cadenas a celda
    prop_geom_cell = cellstr(prop_geom);
    E_columna_cell = num2cell(E_columna);
    G_columna_cell = num2cell(G_columna);
    % Concatenación final de la matriz de diámetros y espesores
    % prop_geom = horzcat(prop_geom, tipo, wo_vector, diam_diam_th, gamma_beta_vector) % ajustes por cambio de Jacket a marco, se omitio diam_diam_th
    % prop_geom = horzcat(prop_geom, tipo, wo_vector, diam_diam_thick_tube_sub, gamma_beta_vector) % ajustes por cambio de Jacket a marco, se omitio diam_diam_th
    prop_geom = [prop_geom_cell, E_columna_cell, G_columna_cell, tipo, wo_vector, diam_diam_thick_tube_sub_cell, gamma_beta_vector]; % ajustes por cambio de Jacket a marco, se omitio diam_diam_th

    %% SECCION: pestaña "fix nodes"
    hoja_excel = 'Joint Assigns - Restraints';
    nodos_restringidos = readmatrix(archivo_excel, 'Sheet', hoja_excel);
    nodos_restringidos = nodos_restringidos(any(~isnan(nodos_restringidos), 2), :);
    nodos_restringidos(:,1:2) = [];
    nodos_restringidos(:,2:7) = [];
    matriz_restriccion = ones(length(nodos_restringidos),6);                % se les agrega numeros porque asi va la estructura de las hojas de excel del dr. Rolando Salgado
    matriz_restriccion = horzcat(nodos_restringidos, matriz_restriccion);

    %% SECCION: pestaña "vxz"
    %% SECCION: Creacion automatica de vectores VXZ para cada elemento del modelo
    % Reuso de variables de Nodos y sus coordenadas
    % Se concatenó cada columna en función a su dirección
    % Las columnas rectas están orientas de manera distinta a las vigas y a las diagonales. Las vigas y diagonales tienen la misma orientación de ejes locales
    % el eje global es:
        % Z mirando hacia arriba
        % X mirando hasta adelante
        % Y mirando hasta atrás
        % Sugerencia: Mejor ver el eje global en el modelo de ETABS ya que no se sabe cuál es adelante y atrás realmente hasta que lo ves en el gráfico

    % Extración de que tipos son cada elemento frame (si viga, columna o elemento diagonal)
    hoja_excel = 'Frame Assigns - Summary'; % Nombre de la pestaña
    columna_texto = readcell(archivo_excel, 'Sheet', hoja_excel, 'Range', 'D:D');   % Lectura de qué tipo de elemento es cada 
    columna_texto(1:2,:) = [];              % Limpieza 
    matriz_ceros = zeros(size(columna_texto, 1), 3);
    for i = 1:length(columna_texto)  % Iterar sobre cada elemento del cell
        if strcmp(columna_texto{i}, 'Beam')
            matriz_ceros(i,3) = 1; % Añadir un 1 en el elemento 3 de la fila i
            % VXZ = 0 0 1
        elseif strcmp(columna_texto{i}, 'Column')
            matriz_ceros(i,1) = 1; % Añadir un 1 en el elemento 1 de la fila i
            % VXZ = 1 0 0
        end
    end
    matriz_num_vxz = matriz_ceros;
    % Números UniqueName de cada elemento frame para despues contatenar con cada tipo y organizar de menor a mayor.
    UniqueName_frame = readmatrix(archivo_excel, 'Sheet', hoja_excel);
    UniqueName_frame = UniqueName_frame(:,3);
    UniqueName_frame(1) = [];
    VXZ = sortrows(horzcat(UniqueName_frame, matriz_num_vxz),1);


% % Modificación de la matriz de masas
% % [masas_en_cada_nodo] = modificacion_matriz_masas(archivo_excel, tirante, d_agua, matriz_cell_secciones, tiempo, densidad_crec);
% [masas_en_cada_nodo] = modificacion_matriz_masas_estructura_sencilla(archivo_excel);
% 
% % Escritura de los datos hacia la hoja de excel del Dr. Rolando
% escritura_datos_hoja_excel_del_dr_Rolando(coordenadas, conectividad, prop_geom, matriz_restriccion, masas_en_cada_nodo, VXZ);
% 
% % % % % Matriz de masas completa y condensada
% % % % [M_cond] = Matriz_M_completa_y_condensada(masas_en_cada_nodo);
% 
% % % Lectura de datos de la hoja de EXCEL del dr. Rolando para la función "Ensamblaje de matrices globales"
% [NE, IDmax, NEn, elements, nodes, damele, eledent, A, Iy, Iz, J, E, G, vxz, ID, KG, KGtu] = lectura_hoja_excel(pathfile);
% % clearvars -except archivo_excel tirante tiempo d_agua densidad_crec pathfile no_elemento_a_danar caso_dano dano_porcentaje coordenadas vxz conectividad prop_geom matriz_restriccion matriz_cell_secciones masas_en_cada_nodo M_cond NE IDmax NEn elements nodes damele eledent A Iy Iz J E G ID KG KGtu hoja_excel vigas_long brac_long col_long num_de_ele_long
% 
% % Danos locales
% % % [ke_d_total, ke_d, elem_con_dano_long_NE] = switch_case_danos(no_elemento_a_danar, caso_dano, dano_porcentaje, archivo_excel, NE, prop_geom, E, G, J);
% prop_geom(:,8:9)    = [];                          % eliminacion de 'circular' y 'wo', si no se eliminan la conversion a matriz numerica no es posible
% 
% % Tabla con no. de elemento y longitud de orden descendente
% hoja_excel = 'Beam Object Connectivity';
% % vigas_long = readmatrix(archivo_excel, hoja_excel, '')
% vigas_long = readmatrix(archivo_excel, 'Sheet', hoja_excel);
% vigas_long(:,2:5) = [];
% vigas_long(:,3) = [];
% % Extracción de datos de las columas (tanto en la subestructura como en al superestructura)
% hoja_excel = 'Brace Object Connectivity'; % pestaña con elementos diagonales (ubicados en la subestructura)
% brac_long = readmatrix(archivo_excel, 'Sheet', hoja_excel);
% brac_long(:,2:5) = [];
% brac_long(:,3) = [];
% hoja_excel = 'Column Object Connectivity'; % pestaña con columnas rectas (generalmente ubicados en la superestructura)
% col_long = readmatrix(archivo_excel, 'Sheet', hoja_excel);
% col_long(:,2:5) = [];
% col_long(:,3) = [];
% num_de_ele_long = sortrows(vertcat(vigas_long,brac_long,col_long),1);
% 
% %% SECCION: Longitudes de elementos a danar (long_elem_con_dano)
% hoja_excel              = 'Frame Assigns - Summary';
% datos_tabla = readtable(archivo_excel, 'Sheet', hoja_excel);
% datos_tabla(1,:) = [];
% uniqueName = datos_tabla.UniqueName;            % Columna C. % Extraer las columnas C (UniqueName) y E (Length mm)
% % % uniqueName = cellfun(@str2double, uniqueName);  % Conversión a matriz      
% length_mm = datos_tabla.Length;                 % Columna E
% datos_para_long = horzcat(uniqueName, length_mm);
% elementos_y_long        = sortrows(datos_para_long, 1);
% for i = 1:length(no_elemento_a_danar)
%     long_elem_con_dano(i)  = elementos_y_long(no_elemento_a_danar(i),2);
% end
% L_d = long_elem_con_dano;
% 
% % Vector que posiciona en un indice del elemento a danar
% [elem_con_dano_long_NE] = vector_asignacion_danos(no_elemento_a_danar, NE);
% 
% % % Matriz de rigidez local con dano aplicado
% [ke_d_total, ke_d, prop_geom_mat] = switch_case_danos(no_elemento_a_danar, num_de_ele_long, L_d, caso_dano, dano_porcentaje, prop_geom, E, G);
% 
% [KG_damaged, KG_undamaged,L, kg] = ensamblaje_matriz_rigidez_global_ambos_modelos(ID, NE, ke_d_total,elements, nodes, IDmax, NEn, damele, eledent, A, Iy, Iz, J, E, G,  vxz, elem_con_dano_long_NE);
% KG_damaged
% 
% %%
% % Cargas aplicadas
% P = [5; 6; 0; 0;0;0; ...
%     5; 6; 0; 0;0;0; ...
%     5; 6; 0; 0;0;0; ...
%     5; 6; 0; 0;0;0]*1000;
% 
% Deform = KG_damaged^-1 * P


%%
% % Función Condensación estática
% KG_damaged_cond   = condensacion_estatica(KG_damaged);



% % Modos y frecuencias de estructura condensados y globales
% [modos_cond_d,frec_cond_d] = modos_frecuencias(KG_damaged_cond,M_cond);

% %%% Verificación de numeros reales en mis frecuencias y formas
% % Verificar si las matrices contienen solo números reales
% real_modos_cond_d = isreal(modos_cond_d);  % Devuelve true
% real_frec_cond_d  = isreal(frec_cond_d);  % Devuelve false
% % Mostrar resultados
% disp(['La matriz modos_cond_d es completamente real: ', num2str(real_modos_cond_d)]);
% disp(['La matriz frec_cond_d es completamente real: ', num2str(real_frec_cond_d)]);
% 
% 
% 
% %%
% clc
% % Implementación del Algoritmo Genetico (AG)
% % Inicializar los vectores LB y UB con el tamaño adecuado para long_x daños
% % Por ahora solo se está considerando la corrosión
% % Cerrar cualquier parallel pool existente
% delete(gcp('nocreate'));
% num_element_sub = 116;
% % long_x = 3 * num_element_sub; % = 348
% % 3 porque solamente se aplica dano al área y ambas inercias en x y en y
% % 116 porque se le aplica dano a los primeros 116 elementos de la subestructura % Configuraciones básicas del AG
% 
% % vector de danos %
% long_x = 1 * num_element_sub;
% 
% Samples     = 100;
% Generations = 200;
% Nvar        = long_x;        % numero de variables que va a tener la variable de dano x. Son 116 elementos de la subestructura * 3 variables de dano de la corrosion = long_x
% options                 = gaoptimset(@ga);          % gaoptimset es para crear las configuraciones específicas para el AG
% options.PopulationSize  = Samples;
% options.Generations     = Generations;
% options.StallGenLimit   = 20;          % límite de generaciones en donde los individuos no cumplen con la función objetivo
% options.Display         = 'iter';                         % Muestra la información en cada iteración
% options.OutputFcn       = @gaoutfun;  % Añade la función de salida para mostrar el tiempo transcurrido
% 
% % Configuraciones específicas del AG
% % Este bloque de código configura funciones específicas que controlan el comportamiento de varios procesos dentro del Algoritmo Genético (GA) en MATLAB. Cada opción define una función que el GA utilizará para diferentes aspectos del proceso de evolución, como la creación de la población inicial, la selección de individuos, la mutación, y si se debe usar o no procesamiento paralelo.
% % el @ le dice al campo de options que haga uso de la función después de @
% options.CreationFcn         = @gacreationlinearfeasible;  % esta línea del dice al AG cómo debe crear la primera generación de los individuos. @gacreationlinearfeasible hace que la primera generación de individuos cumplan con cualquier restricción lineal que defina en el problema. Esto asegura que el AG comience desde un inicio con soluciones válidas y así poder aumentar las probabilidades de que devuelva una respuesta correcta cuando el AG finalice
% 
% % options.FitnessScalingFcn = @fitscalingrank;         % Asigna rangos a los individuos según su aptitud en lugar de escalar los valores directamente, reduciendo el impacto de las grandes diferencias de aptitud y evitando convergencia prematura.
% options.FitnessScalingFcn   = @fitscalingprop;      % fitscalingprop: Esta técnica de escalamiento ajusta los valores de aptitud para que las diferencias entre ellos no sean tan extremas. Esto significa que incluso los individuos con una aptitud no tan alta todavía tienen una oportunidad razonable de ser seleccionados para la reproducción. Uno de los riesgos en los Algoritmos Genéticos (GA) es que si un individuo (o un pequeno grupo de individuos) tiene un valor de aptitud significativamente superior al de los demás en una población, el GA podría converger rápidamente hacia las características de esos individuos. Esto puede llevar a que el algoritmo se quede atrapado en un óptimo local en lugar de encontrar el óptimo global, que es la mejor solución posible en todo el espacio de búsqueda.
% 
% % options.SelectionFcn        = @selectionroulette;        % En este método, la probabilidad de que un individuo sea seleccionado es proporcional a su aptitud. Los individuos con mejores valores de aptitud tienen más probabilidades de ser seleccionados, pero también hay una oportunidad para aquellos con menor aptitud, lo que ayuda a mantener la diversidad genética en la población.
% options.SelectionFcn        = @selectiontournament;        % Este método selecciona grupos al azar (torneos), y dentro de cada torneo, se elige el mejor individuo, favoreciendo la diversidad y mejores aptitudes.
% 
% % Nuevas opciones de cruce comentadas para experimentar
% % options.CrossoverFcn = @crossoverarithmetic; % Cruce aritmético
% % options.CrossoverFcn = @crossoversinglepoint; % Cruce de un punto
% options.CrossoverFcn = @crossovertwopoint; % Cruce de dos puntos
% 
% options.MutationFcn         = @mutationadaptfeasible;     % Configura cómo se llevará a cabo la mutación. Función de Mutación Adaptativa Factible: mutationadaptfeasible es una función específica de MATLAB que realiza mutaciones de manera adaptativa. Aquí está lo que hace: Adaptativa: La mutación es adaptativa porque ajusta el grado de mutación dependiendo del progreso del GA. Si el algoritmo está haciendo buenos progresos, la mutación puede ser menos agresiva. Si no está haciendo mucho progreso, la mutación puede volverse más agresiva para explorar nuevas áreas del espacio de soluciones. Factibilidad: La mutación se realiza de tal manera que los individuos mutados aún cumplen con cualquier restricción del problema. Esto es crucial para asegurarse de que las soluciones mutadas sigan siendo válidas dentro del espacio de búsqueda permitido.
% % options.MutationFcn         = @mutationuniform;
% 
% options.CreationFcn         = @gacreationlinearfeasible;    % Genera la población inicial asegurando que cumpla con restricciones lineales
% options.EliteCount          = 2;                            % Preserva los 2 mejores individuos en cada generación para evitar perder buenas soluciones
% options.FitnessScalingFcn = @fitscalingrank;         % Asigna rangos a los individuos según su aptitud en lugar de escalar los valores directamente, reduciendo el impacto de las grandes diferencias de aptitud y evitando convergencia prematura.
% % options.FitnessScalingFcn   = @fitscalingprop;      % fitscalingprop: Esta técnica de escalamiento ajusta los valores de aptitud para que las diferencias entre ellos no sean tan extremas. Esto significa que incluso los individuos con una aptitud no tan alta todavía tienen una oportunidad razonable de ser seleccionados para la reproducción. Uno de los riesgos en los Algoritmos Genéticos (GA) es que si un individuo (o un pequeno grupo de individuos) tiene un valor de aptitud significativamente superior al de los demás en una población, el GA podría converger rápidamente hacia las características de esos individuos. Esto puede llevar a que el algoritmo se quede atrapado en un óptimo local en lugar de encontrar el óptimo global, que es la mejor solución posible en todo el espacio de búsqueda.
% 
% % options.SelectionFcn        = @selectionroulette;        % En este método, la probabilidad de que un individuo sea seleccionado es proporcional a su aptitud. Los individuos con mejores valores de aptitud tienen más probabilidades de ser seleccionados, pero también hay una oportunidad para aquellos con menor aptitud, lo que ayuda a mantener la diversidad genética en la población.
% options.SelectionFcn = {@selectiontournament, 3}; % Torneo con 3 individuos para favorecer convergencia
% % options.SelectionFcn = {@selectiontournament, 2}; % Torneo con 2 individuos
% % options.SelectionFcn        = @selectiontournament;        % Este método selecciona grupos al azar (torneos), y dentro de cada torneo, se elige el mejor individuo, favoreciendo la diversidad y mejores aptitudes.
% % options.SelectionFcn = {@selectiontournament, 1}; % Solo se selecciona el mejor individuo
% % options.SelectionFcn = @selectionstochunif; % Selección estocástica uniforme
% 
% % options.MutationFcn                               = @mutationadaptfeasible;     % Configura cómo se llevará a cabo la mutación. Función de Mutación Adaptativa Factible: mutationadaptfeasible es una función específica de MATLAB que realiza mutaciones de manera adaptativa. Aquí está lo que hace: Adaptativa: La mutación es adaptativa porque ajusta el grado de mutación dependiendo del progreso del GA. Si el algoritmo está haciendo buenos progresos, la mutación puede ser menos agresiva. Si no está haciendo mucho progreso, la mutación puede volverse más agresiva para explorar nuevas áreas del espacio de soluciones. Factibilidad: La mutación se realiza de tal manera que los individuos mutados aún cumplen con cualquier restricción del problema. Esto es crucial para asegurarse de que las soluciones mutadas sigan siendo válidas dentro del espacio de búsqueda permitido.
% % options.MutationFcn = @(parents,options,nvars,FitnessFcn,state,thisScore,thisPopulation) ...
% %     round(mutationadaptfeasible(parents,options,nvars,FitnessFcn,state,thisScore,thisPopulation) / 0.005) * 0.005;
% % options.MutationFcn    = {@mutationuniform, 0.02}; % Solo el 2% de las variables mutará en cada generación
% % options.MutationFcn = {@mutationuniform, 0.01}; % Solo el 1% de las variables mutará en cada generación
% % options.MutationFcn = {@mutationuniform, 0.005}; % Solo el 0.5% de las variables mutará en cada generación
% % options.MutationFcn = {@mutationuniform, 0.002}; % Solo el 0.2% de las variables mutará
% % options.MutationFcn = {@mutationuniform, 0.001}; % Solo el 0.1% de las variables mutará
% % options.MutationFcn = {@mutationuniform, 0.0005}; % Solo 0.05% de las variables mutarán
% options.MutationFcn = {@mutationuniform, 0.0001}; % Solo el 0.01% de las variables mutará
% 
% 
% % Propósito de la Mutación: La mutación es una operación que introduce variación en los individuos de una población. Es esencial para mantener la diversidad genética, permitiendo que el algoritmo explore nuevas soluciones que no estaban presentes en la población original.
% % Cómo Funciona: Durante la mutación, una pequena parte del código genético (representado por el vector x en tu caso) de un individuo se altera al azar. Esta alteración puede ser un cambio pequeno en el valor de una variable o un ajuste más significativo, dependiendo de cómo esté definida la función de mutación.
% options.UseParallel = 'always';
% % Graficas de monitoreo para ver el estado del AG durante todo su proceso
% options = gaoptimset('PlotFcn', {@gaplotbestf, @gaplotbestindiv, @gaplotdistance, @gaplotrange, @gaplotstopping});
% options.OutputFcn = @gaoutfun;
% % options = gaoptimset('PlotFcn', {@gaplotbestindiv});
% % options = gaoptimset('PlotFcn', {@gaplotbestf, @gaplotbestindiv, @gaplotdistance, @gaplotrange, @gaplotstopping});
% 
% % @gaplotbestf: Mejores valores de función
% % @gaplotbestindiv: Valores del mejor individuo por generación
% % @gaplotdistance: Distancia entre individuos en las soluciones de busqueda
% % @gaplotrange: Rango de valores de la población
% % @gaplotstopping: Criterios de parada del algoritmo
% 
% % Definir los límites de daño
% LowerLim = 0.0;       % Daño mínimo permitido
% UpperLim = 0.9;      % Daño máximo permitido
% 
% LB = LowerLim * ones(long_x, 1);  % Límite inferior
% UB = UpperLim * ones(long_x, 1);  % Límite superior
% 
% % % % % % % Escritura de registros del AG
% % % % % % CWFile='CWFOutput1.txt';    % Nombre del archivo donde irán registrándose los resultados del AG
% % % % % % diary (CWFile);             % Abre el archivo de salida para que todas las salidas en la consola de MATLAB se registren en este archivo
% % 
% % Proceso en paralelo
% parpool('Processes', 6, 'IdleTimeout', 6000);  % Configura n minutos de inactividad antes de apagarse
% % En mi CPU se pueden 6 como máximo, para saber cuántos puede cada usaurio ejecutar en el command window lo siguiente:
% % numCores = feature('numcores');
% % disp(['Número de núcleos: ', num2str(numCores)]);
% % La siguiente linea se a cabo el proceso del ga
% tic;
% %%
% clc
% % Inicialización de las matrices COMAC
% nodos = ((nodes(end,1))-4)*3;
% modos = 3;
% comac_values = zeros(nodos, modos);
% comac_ref = ones(nodos, modos);  % COMAC de referencia, asumimos valores ideales (1)
% 
% [x,fval,exitflag,output,population,scores] = ga(@(x)RMSEfunction(x, num_element_sub, M_cond, frec_cond_d,...
%         L, ID, NE, elements, nodes, IDmax, NEn, damele, eledent, A, Iy, Iz, J, E, G, ...
%         vxz, elem_con_dano_long_NE,...
%         modos_cond_d, prop_geom_mat, no_elemento_a_danar),Nvar,[],[],[],[],LB,UB,[],options);
% 
% % Crear la gráfica de barras
% figure;        % Abre una nueva ventana de figura
% bar(x*100);   % Genera la gráfica de barras
% title('Mejor individuo');  % Título de la gráfica
% xlabel('Elemento con daño');                % Etiqueta del eje X
% ylabel('Porcentaje con daño');                        % Etiqueta del eje Y
% toc;
% % 
% % % % Datos de salida de la funcion ga (Algoritmo Genético de MATLAB):
% % % % fval: Valor mínimo de la función objetivo (RMSE) alcanzado durante la optimización.
% % % % exitflag: Razón por la que el AG terminó (convergencia, límite Ade generaciones, error, etc.).
% % % % output: Estructura que contiene detalles del proceso de optimización, como el número de generaciones, evaluaciones de la función objetivo, y tiempo de ejecución.
% % % % population: Población de individuos en la última generación del AG.
% % % % scores: Valores de la función objetivo (RMSE) para cada individuo en la última generación.
% % % % Datos de entrada de la función ga:
% % % %     Función Objetivo: RMSEfunction es la función objetivo que el AG intenta minimizar.
% % % %     Variables de Optimización: Nvar define el número de variables que se optimizan.
% % % %     Límites: LB y UB+ son los límites inferiores y superiores para las variables de optimización, definidos previamente.
% % %     % Opciones: options incluye todas las configuraciones del AG como el tamaño de la población, número de generaciones, funciones de selección, etc.
% % % % delete(gcp('nocreate'));    % Cierra el procesamiento paralelo
